<html lang="en"> <head > <meta content="text/html; charset&#x3D;utf-8"/>  <title > Jackal Static Site Generator </title> <meta name="description" content="Super Simple Static Site Generator"/>  <meta name="viewport" content="width&#x3D;device-width, initial-scale&#x3D;1, maximum-scale&#x3D;5"/>  <meta name="theme-color" content="#FB966E"/>  <link rel="stylesheet" href="./stylesheets/global.css"/>  </head> <body > <header > <h1 class="pad1"> Jackell Compiler </h1> </header> <article > <p >  <div><p>As mentioned before the compiler is based off of the <a href="https://github.com/jamiebuilds/the-super-tiny-compiler">Super Tiny Compiler</a>.</p><p>I <em>strongly </em>suggest that you read through and maybe even build your own compiler! It's a fun rewarding learning process. Anyway...</p><h2>How it goes:</h2><p>The compiler operates using 6 scripts:</p><p>1. Tokenizer</p><p>2. Parser</p><p>3. Transformer</p><p>4. Traverser</p><p>5. Generator</p><p>6. 'Compiler' script that pulls it all together</p><p>So what do they all do? Let's start with the parser.</p><h3>The Tokenizer</h3><p>Takes a string of code and break it down into an array of tokens. Like this: </p><p><code>tokens = [ {type: 'name', value: 'h1'}, {type: 'colon', value: ':'}, {type: 'bracket', value: '{' }, {type: 'paren', value: '('}, {type: 'arrow', value: '&lt;'}, etc... ]</code></p><p>When the tokenizer encounters a character of interest ({, [, (, etc.) it either grabs only that character and saves it as a token object with a particular 'type' associated with it, or if a string is encountered, the full length of the string is counted as the token. </p><p>For our purposes the tokenizer is interesting because it is where all of the HTML elements and attributes are listed. I have not been exhaustive in accounting for elements and attributes.</p><h3>The Parser</h3><p>The simplest way to conceptualize the Parser is that it loops through the array of tokens, and compiles them into a larger object that includes the token type and value as nodes within that object. Since HTML is nested hierarchically, this object (known in the biz as an Abstract Syntax Tree (AST)) captures this quality nicely. At the end of the script you are left with an AST.</p><h3>Traverser/Transformer</h3><p>The Traverser and Transformer are tightly coupled. The Traverser's job is to navigate the AST provided by the Parser and to enter and exit nodes. The Transformer then defines methods that are called when a node of a certain type is encountered in the AST. This essentially builds the AST from the Parser into a new AST that contains all of the info we need in a format that can be easily digested.</p><h3>Generator</h3><p>This script pulls in the <em>new </em>AST the Transformer created and creates a string of straight HTML baby!</p><h3>Compiler Script</h3><p>This one just pulls the whole thing together and creates a pipeline. The output is routed right into the Handlebars compiler for templating.</p><p></p><p></p></div>  </p> </article> <article > <p >  <div><p>Hey, so you want to write a Jackal file to be compiled to HTML? Okey dokey.</p><p>HTML elements:</p><p><code>h1: {</code></p><p>The opening bracket contains all of the content that will be nested in that element.</p><p>Element attributes like class and id are written inside the bracket as such:</p><p><code>class(className)</code></p><p><code>id(idName)</code></p><p>Square brackets signify string content or other content that is placed in the element.</p><p><code>p:{</code></p><p><code>class(paragraph)</code></p><p><code>[This is going to be inside the p tag!]</code></p><p><code>}</code></p><p>Let's say you have some data coming over from your Sanity IO CMS (or some other data source), how do you put that in so that Handlebars will know how to handle it? Simple! Just include squirley brackets <code>{{ }}</code> as you would in normal HTML.</p><p>Here it is as an attribute:</p><p><code>h1: {</code></p><p><code>   class({{some.value}}) </code></p><p><code>   [Whatever you want your heading to say!]</code></p><p><code>}</code></p><p>Here it is as text content:</p><p><code>h1: {</code></p><p><code>   class(pad1) </code></p><p><code>   [{{some.value}}]</code></p><p><code>}</code></p><p>In cases where you want to escape HTML sent to Handlebars, just use the standard <code>{{{}}}</code> triple brackets syntax.</p><p><code>h1: {</code></p><p><code>   class(pad1) </code></p><p><code>   [{{{some.html}}}]</code></p><p><code>}</code></p><p>You can write HTML within the square brackets by hand as well.</p></div>  </p> </article> <aside > <ul > 
                    <li class="pad2"> <a href="/index.html" >Home</a></li>
                
                    <li class="pad2"> <a href="/documentationOverview.html" >Documentation Overview</a></li>
                
                    <li class="pad2"> <a href="/syntax.html" >Jackle Compiler</a></li>
                
                    <li class="pad2"> <a href="/hbrs.html" >Handlebars Setup</a></li>
                
                    <li class="pad2"> <a href="/sanity.html" >Sanity IO Setup</a></li>
                
                    <li class="pad2"> <a href="/netlify.html" >Netlify Setup</a></li>
                
                    <li class="pad2"> <a href="/cssRef.html" >CSS Class Reference </a></li>
                 </ul> </aside> </body> </html>